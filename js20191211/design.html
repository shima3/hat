<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
    <title>Design of js-hat</title>
    <link rel="stylesheet" href="../github-markdown.css">
    <script type="text/javascript"
	    src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
    </script>
    <script type="text/x-mathjax-config">
      MathJax.Hub.Config({
	  TeX: { equationNumbers: { autoNumber: "AMS" }},
	  tex2jax: {
	      inlineMath: [ ['$','$'], ["\\(","\\)"] ],
	      skipTags: ["script","noscript","style","textarea","pre","kbd"],
	      processEscapes: true
	  },
	  "HTML-CSS": { matchFontHeight: false },
	  displayAlign: "left",
	  displayIndent: "2em"
      });
    </script>
    <style type="text/css">
      code, pre {
	  font-style: normal;
	  font-weight: normal;
	  font-family: "Courier New", Consolas, monospace;
	  color: black;
      }
    </style>
  </head>
  <body class="markdown-body">
    <h1>The Design of js-hat</h1>
    The js-hat is a Hat interpreter written in JavaScript.
    <h2>用語　Terms</h2>
    This page uses the following terms.
    <dl>
      <dt>属性 Attribute</dt>
      <dd>JavaScript言語の各オブジェクトが持つデータです。</dd>
      <dt>Property</dt>
      <dd>Hat言語の各アクターが持つデータです。</dd>
      <dt>省略時継続 Default continuation</dt>
      <dd>ある関数呼び出しにおいて継続の実引数が指定されなかったとき、継続の仮引数に渡される継続です。</dd>
      <dt>連想配列</dt>
      <dd>キーに対応する値を記憶し、効率よく検索できるデータ構造です。</dd>
    </dl>
    <h2>Data structures</h2>
    This interpreter uses the following data structures in JavaScript.
    <dl>
      <dt>タスク <code>Task</code></dt>
      <dd>アクターが実行している処理を表すデータです。<br/>
	以下の属性を持ちます。
	<dl>
	<dt><code>actor</code></dt>
	<dd>このタスクを実行している<code>Actor</code>を示します。</dd>
	<dt><code>call</code></dt>
	<dd>次に実行すべき関数呼び出しを示します。</dd>
	<dt><code>stack</code></dt>
	<dd><code>call</code>を実行するとき、省略時継続として渡される<code>ContStack</code>を示します。</dd>
	</dl>
      </dd>
      
      <dt><a href="../index.html#actor">アクター <code>Actor</code></a></dt>
      <dd>以下の属性を持ちます。
	<dl>
	  <dt><code>mailbox</code></dt>
	  <dd>アクターが受け取ったメッセージのFIFOキューです。</dd>
	  <dt><code>behavior</code></dt>
	  <dd>メッセージの解釈を定義する<code>Behavior</code>です。</dd>
	  <dt><code>plist</code>(propery list)</dt>
	  <dd>アクターが持つプロパティの名前に対する値を記憶する連想配列です。<br/>
	    プログラムの実行中に変更できます。</dd>
	</dl>
      </dd>

      <dt><code>ContStack</code>(Continuation Stack)</dt>
      <dd>継続を要素として持つ単一方向の連結リストです。<br/>
	以下の属性を持ちます。
	<dl>
	  <dt><code>type</code></dt>
	  <dd>型を示します。その値は "contstack" です。</dd>
	  <dt><code>first</code></dt>
	  <dd>先頭の継続を示します。</dd>
	  <dt><code>rest</code></dt>
	  <dd>先頭を除く残りの<code>ContStack</code>を示します。</dd>
	</dl>
	要素が0個の場合、null です。</dd>

      <dt><code>Behavior</code></dt>
      <dd>関数の名前に対する無名関数を記憶する連想配列です。<br/>
	メッセージ中の関数の解釈を定義します。<br/>
	ファイルから読み込まれた後はプログラムの実行中に変更できません。</dd>

      <dt><a href="../index.html#anonymous function">無名関数</a></dt>
      <dd>ハット、ヘッダ、ボディからなる<code>SList</code>です。</dd>

      <dt><a href="../index.html#function call">関数呼び出し</a></dt>
      <dd>先頭が関数、2番目以降が実引数を示す<code>SList</code>です。</dd>
      
      <dt>構文木（Syntax Tree）</dt>
      <dd>S式を構文解析した結果を表すノードからなる木構造です。<br/>
	各ノードは以下の属性を持ちます。
	<dl>
	  <dt><code>type</code></dt>
	  <dd>ノードの型を示す文字列です。</dd>
	  <dt><code>content</code></dt>
	  <dd>ノードの内容を示します。</dd>
	  <dt><code>location</code></dt>
	  <dd>元のS式の範囲を示します。</dd>
	</dl>
	以下の３種のノードがあります。<br/>
	<dl>
	  <dt>SList (List of S-expression)</dt>
	  <dd>S式のリストを示すノードです。<br/>
	    type の値は "list" です。<br/>
	    content は構文木の配列です。</dd>
	  
	  <dt>SAtom (Atom of S-expression)</dt>
	  <dd>S式のアトムを示すノードです。<br/>
	    type の値は "atom" です。<br/>
	    content はアトムの名前を示す文字列です。</dd>
	  
	  <dt>SString (String of S-expression)</dt>
	  <dd>S式の文字列を示すノードです。<br/>
	    type の値は "string" です。<br/>
	    content は、前後のダブルクォートを含まず、エスケープシーケンスを変換済みの文字列です。</dd>
	</dl>
      </dd>

      <!--
      <dt>アクターキュー（Actor Queue）</dt>
      <dd>アクターが実行順に並んだ待ち行列です。</dd>
      <dt></dt>
      <dd></dd>
	  -->
    </dl>
    <h2>Global variables</h2>
    This interpreter defines the following global variables in JavaScript.
    <dl>
      <dt><code>TaskQ</code>(Task Queue)</dt>
      <dd>タスクが実行順に並んだ待ち行列です。</dd>
      <dt><code>CurTask</code>(Current Task)</dt>
      <dd>現在、インタプリタが実行しているタスクです。</dd>
      <dt></dt><dd></dd>
    </dl>
    <h2>Functions of JavaScript</h2>
    This interpreter defines the following functions in JavaScript.
    <dl>
      <dt></dt>
      <dd></dd>
      <dt><code>execute(P, A)</code></dt>
      <dd>プログラム<code>P</code>に文字列の配列<code>A</code>を与えて実行します。</dd>
      <dd>具体的には、P を持つアクターを生成し、そのアクターへメッセージ <code>(main A)</code> を送信します。</dd>

      <dt><code>new Behavior($F$)</code></dt>
      <dd>ファイル名 $F$ のファイルを読み、そこで定義された関数からなる<code>Behavior</code>を生成し、戻り値として返します。</dd>

      <dt><code>new Actor($B$)</code></dt>
      <dd><code>Behavior</code> $B$ を持つアクターを生成し、戻り値として返します。</dd>

      <dt><code>new Task($A$, $C$, $S$)</code></dt>
      <dd><code>Actor</code> $A$、関数呼び出し $C$、<code>ContStack</code> $S$からなるタスクを生成し、戻り値として返します。</dd>
      
      <dt><code>new ContStack($C$, $S$)</code></dt>
      <dd>継続 $C$ を<code>ContStack</code> $S$ の前に追加した<code>ContStack</code>を生成し、戻り値として返します。</dd>
      
      <dt><code>parse($E$)</code></dt>
      <dd>S式 $E$ を構文解析し、木構造の配列を戻り値として返します。<br/>
	<a href="https://github.com/anko/sexpr-plus">sexpr-plus</a> を使用しています。</dd>

      <dt><code>stepTask($T$)</code></dt>
      <dd><code>Task</code> $T$ を一段階実行し、残りの処理に置き換えます。<br/>
	具体的には以下の手順を実行します。<ol>
	  <li><code>CurTask</code>に $T$ を代入します。</li>
	  <li>$T$ の<code>actor</code>を $A$ とおきます。</li>
	  <li>$T$ の<code>call</code>を $C$ とおきます。</li>
	  <li>$T$ の<code>stack</code>を $S$ とおきます。</li>
	  <li>$A$ の<code>behavior</code>を $B$ とおきます。</li>
	  <li>$C$ の先頭の式を $F$ とおきます。</li>
	  <li>$C$ の先頭を除く残りの式からなる列を $R$ とおきます。</li>
	  <li>$B$ から $F$ を検索します。</li>
	  <li>もし、$F$ が見つかれば、それに対応する無名関数に $F$ の値を置き換えます。</li>
	  <li>もし、$F$ の<code>type</code>が<code>"list"</code>ならば、つまり、$F$ が<code>SList</code>ならば<ul>
	      <li>もし、$F$ の先頭がハットならば、つまり、$F$ が無名関数ならば<ol>
		  <li><code>passArgs($F$, $R$, $S$)</code> を呼び出します。</li>
		  <li>その戻り値を $T$ の<code>call</code>に設定します。</li>
	      </ol></li>
	      <li>もし、$F$ の先頭がハットでなければ、つまり、$F$ が関数呼び出しならば <ol>
		  <li>$F$ を $T$ の<code>call</code>に設定します。</li>
		  <li><code>new ContStack(makeArgFunc($R$), S)</code> を呼び出します。</li>
		  <li>その戻り値を $T$ の<code>stack</code>に設定します。</li>
	      </ol></li>
	  </ul></li>
	  <li>もし、$F$ の<code>type</code>が<code>"contstack"</code>ならば、つまり、$F$ が<code>ContStack</code>ならば<ol>
	      <li><code>makeFuncCall($F$ のfirst, $R$)</code> を呼び出します。</li>
	      <li>その戻り値を $T$ の<code>call</code>に設定します。</li>
	      <li>$F$ の<code>rest</code>を $T$ の<code>stack</code>に設定します。</li>
	  </ol></li>
	  <!--
	      <li></li>
	      -->
      </ol></dd>
      <dt><code>passArgs($F$, $R$, $S$, $$)</code></dt>
      <dd>無名関数 $F$ の仮引数に実引数として $R$ を渡した式を戻り値として返します。<br/>
	具体的には、以下の手順を実行します。<ol>
	  <li>getFuncHeader($F$)を呼び出し、その戻り値を $H$ とします。</li>
	  <li>$F$ の通常の仮引数の数を $n_P$ とおきます。</li>
	  <li>$R$ の実引数の数を $n_A$ とおきます。</li>
	  <li>以下のうち条件を満たすものを実行します。<ul>
	      <li>$n_P&lt;n_A$ ならば、</li>
	      <li>$n_P&gt;n_A$ ならば、</li>
	      <li>$n_P=n_A$ ならば、</li>
	  </ul></li>
	  <li></li>
      </ol></dd>
      <dd>$R$ が継続の実引数を持つとき、それを<code>ContStack</code> $S$ の先頭に追加した <code>ContStack</code>を継続の実引数として渡します。</dd>
      <dd>$R$ が継続の実引数を持たないとき、<code>ContStack</code> $S$ を継続の実引数として渡します。</dd>

      <dt><code>makeArgFunc($R$)</code></dt>
      <dd>引数として受け取った関数に $R$ を引数として与える無名関数を作り、戻り値として返します。<br/>
	具体的には、S式<code>(^(__F__) __F__ $R$)</code>で表される<code>SList</code>を返します。<br/>
	ただし、プログラマが変数名や関数名として<code>-F-</code>を使わないことを前提としています。</dd>

      <dt><code>makeFuncCall($F$, $R$)</code></dt>
      <dd>$F$ を関数、$R$ を実引数の列とする関数呼び出しを作り、戻り値として返します。</dd>

      <dt><code>stepTaskQueue( )</code></dt>
      <dd><code>TaskQ</code>の先頭のタスクを一段階実行します。</dd>
      <dd>具体的には以下の手順を実行します。<ol>
	  <li>もし、<code>TaskQ</code>が空ならば、この関数から戻ります。</li>
	  <li><code>TaskQ</code>の先頭のタスクを取り出し、$T$ とおきます。</li>
	  <li><code>stepTask($T$)</code>を呼び出します。</li>
	  <li>もし、$T$ の<code>call</code>が<code>null</code>でなければ、$T$ を<code>TaskQ</code>に追加します。</li>
      </ol></dd>

      <dt><code>sendAsync($A$, $M$)</code></dt>
      <dd>アクター $A$ へメッセージ $M$ を非同期送信します。<br/>
	具体的には、以下の手順を実行します。<ol>
	  <li>もし、$A$ の<code>mailbox</code>が空ならば、<code>startTask($A$, $M$)</code>を呼び出します。</li>
	  <li>$A$ の<code>mailbox</code>に $M$ を追加します。</li>
      </ol></dd>
      
      <dt><code>readyActor($A$)</code></dt>
      <dd>アクター $A$ が<code>mailbox</code>にある次のメッセージの処理を開始します。<br/>
	具体的には、以下の手順を実行します。<ol>
	  <li>もし、<code>mailbox</code>が空ならば、呼び出し元へ戻ります。</li>
	  <li><code>mailbox</code>の先頭のメッセージを取り除きます。</li>
	  <li>もし、<code>mailbox</code>が空ならば、呼び出し元へ戻ります。</li>
	  <li><code>mailbox</code>の先頭のメッセージを $M$ とおきます。</li>
	  <li><code>startTask($A$, $M$)</code>を呼び出します。</li>
      </ol></dd>
      
      <dt><code>getFirst($L$)</code></dt>
      <dd><code>SList</code> $L$ の先頭の要素を戻り値として返します。</dd>

      <dt><code>getRest($L$)</code></dt>
      <dd><code>SList</code> $L$ の先頭を除く残りの<code>SList</code>を戻り値として返します。</dd>

      <dt><code>startTask($A$, $C$)</code></dt>
      <dd>アクター $A$ が関数呼び出し $C$ を実行するタスクを開始します。<br/>
	具体的には、以下の手順を実行します。<ol>
	  <li><code>new Task($A$, $C$, null)</code>を呼び出します。</li>
	  <li>その戻り値の<code>Task</code>を<code>TaskQ</code>に追加します。</li>
      </ol></dd>
      <dt><code>getCurActor( )</code></dt>
      <dd>現在のアクターを戻り値として返します。<br/>
	具体的には<code>CurTask</code>の<code>actor</code>を返します。</dd>
      <!--
      <dt><code></code></dt>
      <dd></dd>
      -->
    </dl>
    <h2>Functions of Hat</h2>
    This interpreter supports the following functions in Hat.
    <dl>
      <dt><code>getBehavior ^($b$)</code></dt>
      <dd>現在のアクターが持つ<code>behavior</code>を変数 $b$ に渡します。</dd>
      <dt><code>newActor $b$ ^($a$)</code></dt>
      <dd><code>Behavior</code> $b$ を持つアクターを新たに生成し、変数 $a$ に渡します。</dd>
      <dt><code>getProperty $N$ ^($v$)</code></dt>
      <dd>プロパティ $N$ の値を変数 $v$ に渡します。</dd>
      <dt><code>setProperty $N$ $v$ ^( )</code></dt>
      <dd>プロパティ $N$ に値 $v$ を設定します。</dd>
      <!--
      <dt><code></code></dt>
      <dd></dd>
      -->
    </dl>
    <h2>検討事項</h2>
    <dl>
      <dt>一つのアクターは複数のメッセージを並行処理するか？</dt>
      <dd><ul>
	  <li>並行処理する場合、競合状態が起こる可能性がある。</li>
	  <li>並行処理しない場合、デッドロックが生じる可能性がある。<br/>
	    例えば、一つのメッセージの処理中に、そのアクター自身または他のアクターへメッセージを送信し、返信を待つとき、デッドロックが生じる。</li>
      </ul></dd>

      <dt>変数に値をどのように代入するか？</dt>
      <dd><ul>
	  <li>全ての変数を値に置き換えた式を生成する。</li>
	  <li>必要な変数のみ値に置き換えた式を生成する。</li>
      </ul></dd>

      <dt></dt><dd></dd>
    </dl>
    <h2>References</h2>
    <ul>
      <li>MDN web docs<ul>
	  <li><a href="https://developer.mozilla.org/ja/docs/Web/API/XMLHttpRequest">XMLHttpRequest</a></li>
	  <li><a href="https://developer.mozilla.org/ja/docs/Web/API/Document/getElementsByTagName">Document.getElementsByTagName()</a></li>
      </ul></li>
      <li>Node.js入門<ul>
	  <li><a href="https://www.sejuku.net/blog/77966">requireの使い方とモジュールの作り方まとめ！</a></li>
	  <li><a href="https://www.sejuku.net/blog/75691">npmの使い方とパッケージ管理の方法まとめ！</a></li>
      </ul></li>
      <li><a href="https://javascript.programmer-reference.com/js-array-slice/">配列内の要素を範囲指定で取り出す</a> コピペで使える JavaScript逆引きリファレンス</li>
      <li><a href="https://www.infoscoop.org/blogjp/2012/05/17/javascript%E3%81%AE%E3%83%87%E3%83%90%E3%83%83%E3%82%B0%E3%81%A7object%E3%81%AE%E4%B8%AD%E8%BA%AB%E3%82%92%E6%96%87%E5%AD%97%E5%88%97%E3%81%A8%E3%81%97%E3%81%A6%E5%B1%95%E9%96%8B%E3%81%99%E3%82%8B/">javascriptのデバッグでobjectの中身を文字列として展開する方法</a> infoScoop開発者ブログ</li>
      <li><a href="https://www.sejuku.net/blog/31671">function(関数)の使い方、呼び出し・戻り値など総まとめ！</a>【JavaScript入門】</li>
      <li><a href="https://qiita.com/butchi_y/items/d6024f81a9eda826fea0">Functionによるevalの代替</a>@butchi_y, Qiita</li>
      <li><a href="https://www.ipentec.com/document/javascript-xmlhttprequest-multi-connect-problem">[JavaScript] XMLHttpRequestで複数のファイルにアクセスしたがレスポンスが1度しかない</a>iPentec</li>
      <li><a href="https://jmatsuzaki.com/archives/16866">JavaScriptで配列やオブジェクトを比較して等しいかチェックする方法</a> jMatsuzaki</li>
      <li><a href="http://www.ituore.com/entry/javascript-for">JavaScriptの色々なfor文｜for・for-each・for-in・for-of</a> いつ俺</li>
      <li><a href="https://pyteyon.hatenablog.com/entry/2018/11/22/184751">JavaScript：同期 / 非同期な読み込みの注意点 - スクリプトの依存関係</a> mathnukoの雑記帳</li>
      <li><a href="http://home.a00.itscom.net/hatada/js-tips/loadserverfile.html">Serverファイルの読み込み</a></li>
      <li><a href="http://tacamy.hatenablog.com/entry/2016/10/16/182658">jQuery.ajax()の代替としてFetch APIをざっくり使ってみる</a> tacamy--log</li>
      <li><a href="https://www.catch.jp/wiki/index.php?javascript_file">Javascriptでファイル読み込みについて調べてみた。</a> catch.jp-wiki</li>
      <li><a href="https://qiita.com/DNA1980/items/11fdb7233fc288ac3502">Node.jsで、存在するはずのmoduleがrequireでエラーになることについて</a> @DNA1980, Qiita</li>
      <li><a href="http://www.tohoho-web.com/js/start.htm">まずは始めてみよう</a></li>
      <li><a href="https://github.com/anko/sexpr-plus">sexpr-plus</a> anko</li>
      <li><a href="https://webbibouroku.com/Blog/Article/js-obj-has-property">オブジェクトのプロパティ判定</a></li>
      <li><a href="https://techacademy.jp/magazine/5541">JavaScriptでsetTimeoutを使う方法【初心者向け】</a></li>
      <li><a href="http://d.hatena.ne.jp/mindcat/20091018/1255889695">JavaScriptのsetIntervaｌ関数の意味を正確に理解するための１つの説明</a></li>
      <li><a href="https://maku77.github.io/js/array/slice.html">配列から部分配列を取得する</a></li>
      <!--
	  <li><a href=""></a></li>
	  -->
    </ul>
  </body>
</html>
    
