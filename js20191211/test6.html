<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<!-- DOCTYPE HTML -->
<html>
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
    <title>Hat: Tutorial</title>
    <link rel="stylesheet" href="../github-markdown.css">
    <!-- script type="text/javascript"
	 src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script -->
    <link rel="stylesheet" href="jquery-linedtextarea.css">
    <link ref="icon" href="/hat/favicon.ico">
    <script type="text/x-mathjax-config">
      MathJax.Hub.Config({
	  TeX: { equationNumbers: { autoNumber: "AMS" }},
	  tex2jax: {
	      inlineMath: [ ['$','$'], ["\\(","\\)"] ],
	      skipTags: ["script","noscript","style","textarea","kbd"],
	      processEscapes: true
	  },
	  "HTML-CSS": { matchFontHeight: false },
	  displayAlign: "left",
	  displayIndent: "2em"
      });
    </script>
    <style type="text/css">
      .code {
	  font-style: normal;
	  font-weight: normal;
	  font-family: "Osaka-Mono", "Courier New", Consolas, monospace;
      }
      .full {
	  width: 100%;
	  height: 100%;
      }
      .border {
	  border: solid 1px black;
	  // background-color: black;
      }
      .stripe {
	  background: repeating-linear-gradient(
	      45deg,     /* 角度の指定 */
	      #fff,      /* 色A ... 開始 */
	      #fff 3px,  /* 色A ... 終了 */
	      #000 3px,      /* 色B ... 開始 */
	      #000 6px   /* 色B ... 終了 */
	  );
      }
      .checker {
	  background-color: #fff;
	  background-image:
	      linear-gradient(45deg, #ccc 25%, transparent 25%,
			      transparent 75%, #ccc 75%, #ccc),
	      linear-gradient(45deg, #ccc 25%, transparent 25%,
			      transparent 75%, #ccc 75%, #ccc);
	  background-position: 0 0, 5px 5px;
	  background-size: 10px 10px;
      }
      .right-float {
	  float: right;
      }
    </style>
    <script src="sexpr-plus.js"></script>
    <script src="taterm.js"></script>
    <script src="hat.js"></script>
    <script src="https://cdn.jsdelivr.net/gh/google/code-prettify@master/loader/run_prettify.js"></script>
    <script type="text/javascript" src="jquery-3.4.1.js"></script>
    <script type="text/javascript" src="jquery-linedtextarea.js"></script>
  </head>
  <body class="markdown-body">
    <!-- body class=full -->
    <form action="#">
      <!-- table width="99%" height="99%">
	<tr>
	  <td width="50%" height="100%" rowspan="4" align="left" valign="top" -->
	      <div style="width:49%; height:100%; float:left; overflow:scroll;">
		<h1>Hat言語のチュートリアル</h1>
		このページはGoogle Chromeにしか対応していません。
	    <h2>定番 hello, world</h2>
	    <div class="sourcefile right-float">
	      <input type="text" value="sample1.sch" disabled />
	      <input type="button" value="Run"
		     onclick="runCode(this)"/><br>
	      <textarea id="text" class="lined" cols="40" rows="6"
			spellcheck="false"></textarea>
	    </div>
	    Sample1.schの右のRunボタンを押して実行してください。
	    Terminal:の下の枠内に
	    <pre>hello,
 world</pre>と出力します。
	    <br>
3行目のdefineCPSで関数mainを定義しています。
4行目と5行目のprint関数で文字列を出力します。
ダブルクォートで挟まれた部分が文字列です。
文字列中に改行コード\nがあると改行します。
改行コードがなければ、そのまま右に続けて出力します。
<br>
4行目の"hello,\n"の改行コードを削除してから、もう一度、Runボタンを押してみてください。
hello, world
と出力します。
もし書き換えておかしくなった場合、リロードすれば元に戻ります。
<br>
6行目のexit関数でプログラムを終了します。
引数が0のときは正常終了、0以外のときは異常終了を意味します。
<br>
3行目の行末の^( )はmain関数に引数がないことを意味します。
4行目の5行目の行末の^( )は次の行が別の関数呼び出しであることを意味します。
これがないと引数が続いているとみなされ、正しく実行できません。

<h2>図形の表示</h2>
<div class="sourcefile right-float">
  <input type="text" value="sample2.sch" disabled />
  <input type="button" value="Run"
	 onclick="runCode(this)"/><br>
  <textarea id="text" class="lined" cols="60" rows="8"
	    spellcheck="false"></textarea>
</div>
sample2.schの右のRunボタンを押して実行してください。
Canvas:の下の枠に直線、三角形、四角形、楕円を表示します。
<br>
4行目のline関数で座標(200,100)から(100,200)までの直線を引きます。
5行目のtriangle関数で頂点(300,100),(400,200),(300,200)からなる三角形を表示します。
6行目のrect関数で座標(100,300)から幅100、高さ200の長方形を表示します。
7行目のellipse関数で座標(300,400)を中心とする幅100、高さ200の楕円の角度-90（上方向）から90度（下方向）まで時計回りの円弧を表示します。
<br>
line, triangle, rect, ellipse関数の引数を変更して実行し、位置や大きさがどのように変わるか確認してください。

<h2>テキストの表示</h2>
<div class="sourcefile right-float">
  <input type="text" value="sample3.sch" disabled />
  <input type="button" value="Run" onclick="runCode(this)"/><br>
  <textarea id="text" class="lined" cols="40" rows="9"
	    spellcheck="false"></textarea>
</div>
sample3.schの右のRunボタンを押して実行してください。
Canvasに文字列helloとworldを表示します。
<br>
4行目のtext_size関数で文字の大きさを50pxに設定します。
5行目のtext_align関数で左揃えに設定します。
6行目のtext関数で文字列helloを座標300,500に表示します。
左揃えなのでhelloの左端がX座標300になります。
7行目のtext_align関数で中央揃えに設定します。
8行目のtext関数で文字列worldを座標300,600に表示します。
中央揃えなのでworldの真ん中がX座標300になります。
<br>
text_size, text_align, text関数の引数を変更し、実行してみてください。
ただし、text_align関数の引数は"left", "center", "right"のどれかです。

<h2>線の幅と色の設定</h2>
<div class="sourcefile right-float">
  <input type="text" value="sample4.sch" disabled />
  <input type="button" value="Run" onclick="runCode(this)"/><br>
  <textarea id="text" class="lined" cols="60" rows="9"
	    spellcheck="false"></textarea>
</div>
sample4.schの右のRunボタンを押して実行してください。
Canvasに直線、三角形、四角形、楕円、文字列を表示します。
直線や図形の輪郭は青色、図形の内部は緑色になります。
<br>
4行目のline_width関数で線の幅を2に設定しています。
5行目のstroke_rgb関数で線の色を青に設定しています。
色は光の三原色（赤緑青）の各256段階（0から255まで）の数値で指定します。
6行目のfill_rgb関数で図形の内部を塗りつぶす色を緑に設定しています。
7行目から10行目はsample2.schの4行目から7行目と同じです。
11行目から15行目はsample3.schの4行目から8行目と同じです。
<br>
輪郭の幅や塗りつぶしの色などを変更して実行し、どのように変化するか確認してください。
また、line_width, stroke_rgb, fill_rgbなどの行をコピーし、他の行の間に挿入し、引数を変更して実行してみてください。
図形によって異なる輪郭の幅や色、塗りつぶしの色などを設定することができます。

<h2>練習課題１</h2>
<div class="sourcefile right-float">
  <input type="text" value="exercise1.sch" disabled />
  <input type="button" value="Run" onclick="runCode(this)"/><br>
  <textarea id="text" class="lined" cols="60" rows="9"
	    spellcheck="false"></textarea>
</div>
トランプのカードを表示するプログラムを作成してください。
トランプのどのカードでも、1枚だけでも良いです。
作成したプログラムをexercise1.schに入力して実行し、表示を確認してください。
Hat言語を用い、右のCanvasに表示するようにしてください。
;;で始まる行はコメントですので、処理に影響を与えません。
入力したプログラムはリロードすると消えてしまうので、エディタなどにコピペして保存してください。

<h2>四則演算と数値出力</h2>
<div class="sourcefile right-float">
  <input type="text" value="sample6.sch" disabled />
  <input type="button" value="Run" onclick="runCode(this)"/><br>
  <textarea id="text" class="lined" cols="50" rows="13"
	    spellcheck="false"></textarea>
</div>
sample6.schの右のRunボタンを押して実行してください。
2つの数値3と2の加減乗除を出力します。
<br>
4行目の 3 2 ^(a b) で数値3を変数aに渡し、数値2を変数bに渡します。
5行目の a + b ^(c) でaとbの和を変数cに渡し、- * / についても同様です。
C言語とは異なり、整数同士の除算 / でも実数になります。
<br>
変数、数値、演算子は空白で区切る必要があります。
カッコの前後は空白で区切る必要はありません。
<br>
printのカッコ内に変数や文字列を並べると連続して出力します。
変数や文字列の間にカンマなどは入れてはいけません。
4行目の3や2の数値を適当に書き換えて実行し、出力に反映されることを確認してください。

<h2>比較演算子と選択処理</h2>
<div class="sourcefile right-float">
  <input type="text" value="sample7.sch" disabled />
  <input type="button" value="Run" onclick="runCode(this)"/><br>
  <textarea id="text" class="lined" cols="60" rows="13"
	    spellcheck="false"></textarea>
</div>
sample7.schの右のRunボタンを押して実行してください。
x=-1と0との大小関係を出力します。
<br>
比較演算子として <, >, =, <>, <=, >= が使えます。
等号 = と不等号 <> がC言語と異なります。
<br>
if文は3つの引数をとり、第1引数が真のときは第2引数を実行し、第1引数が偽のときは第3引数を実行します。
6行目は5行目のif文の第3引数です。
同様に、8行目は7行目のif文の第3引数です。
よって、5行目と7行目の末尾に^( )をつけてはいけません。
<br>
9行目と10行目は、if文の第1引数が偽のとき実行すべき処理がない場合の例です。
そのような場合は第3引数を nop とします。
nop は何もせずに次に進む関数です。
<br>
unless文は2つの引数をとり、第1引数が真のときは何もせず、偽のときは第2引数を実行します。
<br>
-1を別の値に書き換えて実行し、出力が正しいか確認してください。

<h2>アニメーション</h2>
<div class="sourcefile right-float">
  <input type="text" value="sampleA.sch" disabled />
  <input type="button" value="Run" onclick="runCode(this)"/><br>
  <textarea id="text" class="lined" cols="60" rows="13"
	    spellcheck="false"></textarea>
</div>

	      </div>
	      <div id="wrapper" style="width:49%; height:98%; float:right;">
		<div id="upper">
		Terminal:
	    <input type="button" id="stop" value="Stop"
		   onclick="HatInterpreter.stop()"/>
	    <input type="button" id="restart" value="Restart"
		   onclick="HatInterpreter.restart()"/>
	    <input type="button" name="clear" value="Clear"
		   onclick="terminal.value=''"/>
	      <textarea class="code full" id="terminal" style="height:25em; box-sizeing:border-box;"></textarea>
</div>
	      Canvas:
	    <input type="button" name="clear" value="Clear"
		   onclick="resetCanvas()"/>
	    <canvas id="canvas" class="checker"></canvas>
</div>
    </form>
    <script type="text/javascript">
      $(function(){
	  $(".lined").linedtextarea(
	      //	      {selectedLine: 1}
	  );
      });
      var term=TATerm("terminal");
      function printPrompt( ){
	  term.print("OK> ");
      }
      term.onInput=function(str){
	  this.print(str);
	  this.print("\n");
	  printPrompt( )
      };
      function hat_print(arg){
	  if(arg==null) return;
	  // console.log("hat_print arg="+arg);
	  var first=arg.getFirst( );
	  if(first){
	      if(first.string) term.print(first.string);
	      else term.print(first.toString( ));
	  }else term.print("()");
	  hat_print(arg.getRest( ));
      }
      var splitted_command_line;
      function hat_get_command_line_args(){
	  return HatInterpreter.makeSequence(splitted_command_line.slice(1), 0);
      }
      var exit_status=0;
      function hat_exit(status){
	  // exit_status=parseInt(status.toString());
	  exit_status=status;
	  HatInterpreter.stop();
      }
      function runProgram(){
	  // console.log("runProgram");
	  var path=document.getElementById("path");
	  var command=document.getElementById("command");
	  var program=document.getElementById("program");
	  /*
	   console.log("path: "+path.value);
	   console.log("command: "+command.value);
	   console.log("program: "+program.value);
	  */
	  // HatInterpreter.startCode(path.value, program.value, command.value);
	  splitted_command_line=command.value.split(/\s/);
	  HatInterpreter.startCode(path.value, program.value,
				   command.value);
	  //				  splitted_command_line[0]);
      }
      function getTextInput(node){
	  for(let child of node.getElementsByTagName("input")){
	      if(child.type=="text") return child;
	  }
	  return null;
      }
      function getTextArea(node){
	  let list=node.getElementsByTagName("textarea");
	  return list[0];
      }
      function runCode(button){
	  resetCanvas();
	  let input=getTextInput(button.parentNode);
	  let text=getTextArea(button.parentNode);
	  // console.log("text="+text.value);
	  HatInterpreter.startCode(input.value, text.value, "main");
      }
      function snap(){
	  var image=document.getElementById("image");
	  image.src=canvas.toDataURL("image/png");
      }
      var terminal=document.getElementById("terminal");
      var upper=document.getElementById("upper");
      var wrapper=document.getElementById("wrapper");
      var canvas=document.getElementById("canvas");
      // console.log(canvas.width+", "+canvas.height);
      let context2d=canvas.getContext('2d');
      let stroke_flag=true, fill_flag=false;
      let initialStrokeStyle=context2d.strokeStyle;
      let initialFillStyle=context2d.fillStyle;

      fitCanvas();
      window.onresize=fitCanvas;

      function fitCanvas(){
	  canvas.width=wrapper.clientWidth;
	  canvas.height=wrapper.clientHeight-upper.clientHeight;
      };
      function resetCanvas(){
	  context2d.strokeStyle=initialStrokeStyle;
	  context2d.fillStyle=initialFillStyle;
	  context2d.clearRect(0, 0, canvas.width, canvas.height);
	  stroke_flag=true;
	  fill_flag=false;
      }
      function fill_stroke(){
	  if(fill_flag) context2d.fill();
	  if(stroke_flag) context2d.stroke();
      }
      function hatStrokeRGB(red, green, blue){
	  context2d.strokeStyle='rgb('+red+','+green+','+blue+')';
	  stroke_flag=true;
      }
      function hatNoStroke(){
	  stroke_flag=false;
      }
      function hatFillRGB(red, green, blue){
	  context2d.fillStyle='rgb('+red+','+green+','+blue+')';
	  fill_flag=true;
      }
      function hatNoFill(){
	  fill_flag=false;
      }
      function fillRect(x, y, w, h){
	  context2d.fillRect(x, y, w, h);
      }
      function strokeRect(x, y, w, h){
	  context2d.strokeRect(x, y, w, h);
      }
      function hatLine(x1, y1, x2, y2){
	  context2d.beginPath();
	  context2d.moveTo(x1, y1);
	  context2d.lineTo(x2, y2);
	  context2d.stroke();
      }
      function hatTriangle(x1, y1, x2, y2, x3, y3){
	  context2d.beginPath();
	  context2d.moveTo(x1, y1);
	  context2d.lineTo(x2, y2);
	  context2d.lineTo(x3, y3);
	  context2d.closePath();
	  fill_stroke();
      }
      function hatRect(x, y, w, h){
	  context2d.rect(x, y, w, h);
	  fill_stroke();
      }
      function degree2radian(degree){
	  return degree*Math.PI/180;
      }
      function hatEllipse(x, y, w, h, s, e){
	  s=degree2radian(s);
	  e=degree2radian(e);
	  context2d.beginPath();
	  context2d.translate(x, y);
	  if(w<h){
	      context2d.scale(1, h/w);
	      context2d.arc(0, 0, w/2, s, e);
	  }else{
	      context2d.scale(w/h, 1);
	      context2d.arc(0, 0, h/2, s, e);
	  }
	  fill_stroke();
	  context2d.setTransform(1, 0, 0, 1, 0, 0);
      }
      function hatLineWidth(width){
	  context2d.lineWidth=width;
      }
      function hatText(text, x, y){
	  if(fill_flag) context2d.fillText(text, x, y);
	  if(stroke_flag) context2d.strokeText(text, x, y);
      }
      let fontStyle="normal", fontSize=10, fontFamily="Osaka-Mono";
      function setFont(){
	  context2d.font=fontStyle+" "+fontSize+"px "+fontFamily;
      }
      function hatTextSize(size){
	  fontSize=size;
	  setFont();
      }
      function hatTextAlign(align){
	  context2d.textAlign=align;
      }
      function hatFillCanvas(){
	  context2d.fillRect(0, 0, canvas.width, canvas.height);
      }
      function hatGetCanvasSize(){
	  return [canvas.width, canvas.height];
      }

      for(let node of document.getElementsByClassName("sourcefile")){
	  let input;
	  for(input of node.getElementsByTagName("input"))
	      if(input.type=="text") break;
	  if(!input) break;
	  let path=input.value;
	  let list=node.getElementsByTagName("textarea");
	  let text=list[0];
	  let xmlHttp=new XMLHttpRequest();
	  xmlHttp.onreadystatechange=function(){
	      if(xmlHttp.readyState == 4 && xmlHttp.status == 200){
		  text.innerHTML = xmlHttp.responseText;
	      }
	  };
	  xmlHttp.open("GET", path, true);
	  xmlHttp.send(null);
      }
    </script>
  </body>
</html>
